<!DOCTYPE html>
<html lang="bg">
    <head>
        <title>Есе</title>
    </head>
    <body>
        <h1>Описание на моят basic blockchain protocol.</h1>
        <br>

        <h2>Правила, които ще следва:</h2>
        <ol>
            <li>Обслужва крипто платежни транзакции в децентрализирана мрежа;</li>
            <li>За хеширане използва криптографска хеш функция - <a href="#sha256">SHA256</a>;</li>
            <li>Транзакциите се подписват. <a href="#ecdsa">Elliptic Curve Digital Signature Algorithm (ECDSA)</a>;</li>
            <li>Средно време за генериране на блок ще е 3 мин;</li>
            <li>Размерът на блок ще е 30 транзакции;</li>
            <li>В мрежа потребителите си изпращат цифрови токени;</li>
            <li>В началото тези токени ще са конкретен брой;</li>
            <li>Proof-of-work ще е consensus algorithm - спец. участници, наречени миньори се състезават един срещу друг, за да решат пъзел, да завършат транзакции в мрежата и да получат награда.
            Важно е да има наличие на голяма изчислителна мощност, а не токени, за възможност за копаене;</li>
            <li>Пъзелът ще е <a href="#hashcash">Hashcash</a>.</li>
        </ol>

        <h3 id="sha256"> SHA256 </h3>
        <p>Хешира се обект чрез неговите променливи, т.е информацията, която носи.</p>

        <h3 id="hashcash"> Hashcash </h3>
        <p>Компютърът участва на случаен принцип в хеширащи функции, докато стигне до изход с правилното минимално количество водещи нули. Броят на тези нули
        се определя от число difficulty, което се регулира така, че да не се стигне до прекалено лесно решаване на пъзела или пък до невъзможно решаване.
        Трудността се променя на определен брой блокове. Пр: при Bitcoin - Този избор е предназначен да се извършва приблизително на всеки две седмици. 2 седмици / 10 минути = 14 * 24 * 60 / 10 = 2016 г.
        Ако старият набор от блокове завърши твърде бързо, целта се понижава (трудността се повишава), което гарантира, че ще отнеме повече време за решаването на тези нови блокове...
        и обратно. По този начин трудността се колебае около идеалните 2 седмици (и 10 минути на блок).</p>

        <h3 id="ecdsa"> Elliptic Curve Digital Signature Algorithm (ECDSA) </h3>
        <p>ECDSA е криптографията зад частните и публичните ключове. Използва се за генериране на частен ключ и позволява лесно изчисление на съответен публичен ключ.
        Не може да се вземе публичен ключ (свой или някой чужд) и лесно да се изчисли частен ключ. Ще са необходими трилиони компютри, трилиони години непрекъснато отгатване на различни частни ключове,
        за да се разбере кой от тях създава даден публичен ключ.</p>

        <h2>Решения за сигурност</h2>
        <ul>
            <li>Хешът на всеки блок е свързан с предишния;</li>
            <li>Подписване на транзакции - гарантира, че средствата могат да бъдат изразходвани само от техните законни собственици;</li>
            <li>Миньорите, поддържащи мрежата, получават токени - икономически стимул.</li>
        </ul>

        <h2>Структура на компонентите</h2>
        <p>Какво представлява структурата на блокчейн данните в най-базов вариант:</p><br>
        <img src="https://www.bcs.org/media/5414/a-simple-blockchain.jpg?width=900&height=675" alt="Not found.">
        <p>От тук може да се направи първо много базово определение, че това е <a href="#chain">chain</a>, който съдържа
        в себе си масив от <a href="#block">блокове</a>, които от своя страна съдържат масив от <a href="#tx">транзакции</a>. Това ще са и моите основните
        даннови компоненти.</p>

        <h3 id="chain">Chain</h3>
        <p>Масивът от блокове, осигуряващ тяхната връзка.</p><br>
        <ol>
            <li>Базови полета:
                <ul>
                    <li>blocks, [] - масив от блоковете на блокчейна;</li>
                    <li>pendingTransactions, [] - масив от транзакциите, които чакат да бъдат добавени в блок. Транзакциите, които се генерират във времето между блоковете (10 мин при Bitcoin);</li>
                    <li>difficulty, number - число определящо "сложността на мрежата". Това е част от постигане на консенсус алгоритъма;</li>
                    <li>reward, number - награда за участниците поддържащи мрежата.</li>
                </ul>
            </li>
            <li>Базови методи:
                <ul>
                    <li>genesisBlock () -  създава първият блок от чейна, който не съдържа транзакции;</li>
                    <li>getLastBlock () - получаване на последния блок;</li>
                    <li>(mine)addPendingTransactions() - miner извиква функцията, преда си адреса и създава блок с масива от чакащи транзакции (реално не се добавят всички, а има някакъв метод на подбор, все пак си има и block size),
                    прикача го към последния блок и се "копае" блокът, след което се изпразва списъка с чакащи транзакции и miner-ът получава reward чрез иницииране на транзакция;</li>
                    <li>isValidChain () - функция, в която ще са описани някакви правила, гарантиращи базова сигурност (пр:
                    проверява дали блоковете в чейна са  свързани правилно (според индекса им в масива, защото това има дава подредбата),
                    дали hash-ирането им е правилно, според функцията за хеширане).
                    </li>
                </ul>
            </li>
        </ol>

        <h3 id="block">Блок</h3>
        <p>Блок, съдържащ транзакции за добавяне към мрежата.</p><br>
        <ol>
            <li>Базови полета:
                <ul>
                    <li>timestamp, string - кога блокът е създаден;</li>
                    <li>previousHash, string - важно поле, което показва кой е блокът преди текущия;</li>
                    <li>nonce, number - random номер, който се използва за да се променя, за да може да се променя и hash-а следователно при копаенето на блока (PoW);</li>
                    <li>transactions, [] - транзакции, които блокът ще съдържа;</li>
                    <li>hash, string - ще се изчислява от специален метод използващ криптографска функция.</li>
                </ul>
            </li>
            <li>Базови методи:
                <ul>
                    <li>calcHash () -  генерира хеш, спрямо данните на блока;</li>
                    <li>mineBlock () - функция, която ще приема параметъра difficulty и ще осигурява консенсус механизъм.
                    </li>
                </ul>
            </li>
        </ol>

        <h3 id="tx">Транзакция</h3>
        <br>
        <ol>
            <li>Базови полета:
                <ul>
                    <li>fromAddress, string;</li>
                    <li>toAddress, string;</li>
                    <li>amount, number.</li>
                </ul>
            </li>
            <li>Базови методи:
                <ul>
                    <li>getBalanceOfAddress () -  минава се през транзакциите и се намира това, което наричаме баланс -
                    ако при транзакции, адресът ни се срещне като fromAddres, намаляме стойността, в противен случай - увеличаваме;</li>
                    <li>calcHash ();</li>
                    <li>sigTransactions.</li>
                </ul>
            </li>
        </ol>
    </body>
</html>